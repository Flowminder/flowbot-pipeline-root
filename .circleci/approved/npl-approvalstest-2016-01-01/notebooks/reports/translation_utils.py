from enum import Enum, auto
from hashlib import md5
import json
from pprint import pprint
from typing import Callable, Generator, List
import re

from bs4 import BeautifulSoup, Comment, NavigableString, Tag
from dataclasses import dataclass, fields
from pathlib import Path

from dataclasses import dataclass
from pathlib import Path

INLINE_ELEMENTS = [
    "a",
    "abbr",
    "acronym",
    "b",
    "bdo",
    "big",
    "br",
    "button",
    "cite",
    "code",
    "dfn",
    "em",
    "i",
    "img",
    "input",
    "kbd",
    "label",
    "map",
    "object",
    "output",
    "q",
    "samp",
    "script",
    "select",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "textarea",
    "time",
    "tt",
    "var",
]


class Languages(Enum):
    "en" == auto()
    "fr" == auto()


def short_id(s: str) -> str:
    return md5(s.encode()).hexdigest()[:5]


@dataclass
class TranslatorConfig:
    translation_folder: Path
    available_translations: List = None

    def __post_init__(self):
        if not self.translation_folder.exists():
            raise FileNotFoundError
        if not self.available_translations:
            self.available_translations = [
                language.name for language in self.translation_folder.iterdir()
            ]
        else:
            for lang in self.available_translations:
                (self.translation_folder / lang).mkdir(exist_ok=True)


def get_translation(language: Languages, trans_config: TranslatorConfig) -> dict:
    if language not in trans_config.available_translations:
        raise NotImplementedError(
            f"Translations for language {language} are not yet available."
        )
    with open(trans_config.translation_folder / language / "translation.json") as fp:
        return json.load(fp)


@dataclass
class DestyledTag:
    original_tag: Tag
    new_tag: Tag
    formatting: dict

    def __post_init__(self):
        self.style_string = "\n".join(
            f".{class_id} {{ {class_styling} }}"
            for class_id, class_styling in self.formatting.items()
        )
        trans_str = self.new_tag.text
        for class_id in self.formatting.keys():
            trans_str = trans_str.replace(f"<span class={class_id}>", f"[{class_id} ")
        trans_str = trans_str.replace("</span>", "]")
        self.translatable_string = trans_str


def deformat_text(tag: Tag, soup: BeautifulSoup) -> DestyledTag:
    # Removes and (saves?) the formatting for text so it can be dumped into a tranlation json all as one
    new_children = []
    formatting_dict = {}
    for span in tag.children:
        style_id = "f" + short_id(span["style"])
        formatting_dict[style_id] = span["style"]
        new_div = soup.new_tag(name="span", attrs={"class": style_id})
        new_div.string = span.text
        new_children.append(new_div)

    new_tag = tag
    new_tag.clear()
    for c in new_children:
        new_tag.append(c)

    tag.replace_with(new_tag)

    return DestyledTag(tag, new_tag, formatting_dict)


@dataclass
class TranslatableTag:
    tag: Tag
    translatable_string: str


def strip_inline_formatting(
    to_add: List[DestyledTag], in_page: BeautifulSoup
) -> BeautifulSoup:
    #
    page = in_page
    generated_style_tag = page.new_tag("style")
    generated_style_tag.string = "\n".join(ds.style_string for ds in to_add)
    page.insert(0, generated_style_tag)
    page.insert(
        0,
        Comment("This is autogenerated styling as a workaround for a Weasyprint issue"),
    )
    return page


def literal_inner(tag) -> str:
    return "".join(str(c) for c in tag.contents)


def prepare_translations(
    to_translate: List[Tag],
    file_name: str,
    config: TranslatorConfig,
    overwrite_existing: bool = False,
) -> dict:

    trans_dict = {
        "t" + short_id(literal_inner(tag)): literal_inner(tag) for tag in to_translate
    }
    for language in config.available_translations:
        out_path = (config.translation_folder / language / file_name).with_suffix(
            ".json"
        )
        if out_path.exists() and not overwrite_existing:
            print(f"{out_path} exists already, skipping.")
            continue
        out_path.write_text(json.dumps(trans_dict))

    return trans_dict


def literal_text_searcher_factory(target_tag: Tag) -> Callable:
    # There has to be a better way of finding whether two tags have a literal text match than this
    return lambda tag: literal_inner(tag) == literal_inner(target_tag)


def detranslate(
    to_translate: List[Tag], translations: dict, soup: BeautifulSoup
) -> BeautifulSoup:
    # Replaces all tags in to_translate with their translation ID from prepare_translations
    new_soup = soup
    for translatable in to_translate:
        translation_id = "t" + short_id(literal_inner(translatable))
        if translation_id not in translations.keys():
            print(f"Translation for {translation_id} not found")
            continue
        finder = literal_text_searcher_factory(translatable)
        new_soup.find(finder, recursive=True).string = r"{{ " + translation_id + r" }}"
    return new_soup


def is_figma_formatted(tag) -> bool:
    # Figma likes to do inline formatting using <span> tags with inline styling.
    # We are assuming that any element with <span> is inline foratted
    return any(child.name == "span" for child in tag.contents) and len(tag.contents) > 0


def is_inline_formatted(tag) -> bool:
    return (
        all(
            isinstance(child, NavigableString) or child.name in INLINE_ELEMENTS
            for child in tag.contents
        )
        and len(tag.contents) > 0
    )


def is_just_jinja(tag) -> bool:
    # Regex matches a string that is just a jinja tag
    # https://regex101.com/r/l7nmzq/1
    return len(tag.contents) == 1 and re.match(r"^{{[\w, ]+}}$", tag.contents[0])


def is_translatable(tag) -> bool:
    return (
        is_inline_formatted(tag)
        and len(tag.contents) > 0
        and not is_inline_formatted(tag.parent)
        and not is_just_jinja(tag)
    )


def make_translatable(
    page_path: Path,
    config: TranslatorConfig,
    overwrite_jsons=False,
    backup_original=True,
):
    if backup_original:
        backup_path = page_path.with_name(page_path.name + ".back")
        backup_path.write_text(page_path.read_text())
    soup = BeautifulSoup(page_path.read_text())
    tags_to_deformat = [
        deformat_text(s, soup) for s in soup.find_all(is_figma_formatted)
    ]
    print("Text to deformat:")
    print(str(t) for t in tags_to_deformat)
    soup = strip_inline_formatting(tags_to_deformat, soup)
    tags_to_translate = soup.find_all(is_translatable)
    print("Text to translate:")
    for t in tags_to_translate:
        print(literal_inner(t))
    translations = prepare_translations(
        tags_to_translate, page_path.name, config, overwrite_existing=overwrite_jsons
    )
    soup = detranslate(tags_to_translate, translations, soup)
    page_path.write_text(str(soup))


def translations(page_name: str, config: TranslatorConfig) -> Generator:
    page_name = Path(page_name)
    for country in config.available_translations:
        trans_path = (
            config.translation_folder / country / page_name.with_suffix(".json").name
        )
        yield country, json.loads(trans_path.read_text())


if __name__ == "__main__":

    import argparse

    parser = argparse.ArgumentParser(
        prog="Translation maker",
        description="Converts a template from Figma-brand HTML to translatable templates",
    )
    parser.add_argument(
        "files", nargs="+", help="List of template file to make translatable"
    )
    parser.add_argument(
        "translation_folder", help="The folder to place the translation jsons"
    )
    args = parser.parse_args()
    config = TranslatorConfig(
        translation_folder=Path(args.translation_folder),
        available_translations=["en", "fr"],
    )
    for file in args.files:
        make_translatable(Path(file), config, overwrite_jsons=True)
